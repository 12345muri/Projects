函数执行顺序：
1、原始数据表 2、from 3、on 4、join 5、where 6、group by / count 7、having 8、select 9、order by 
最后是row_number()//给行编号 over(partition by//以什么分区 order by //以什么排序) 


1731每位经理的下属员工数量
我们将至少有一个其他员工需要向他汇报的员工，视为一个经理。
Employees 表：
| employee_id | name    | reports_to | age |
| 9           | Hercy   | null       | 43  |
| 6           | Alice   | 9          | 41  |
输出：
| employee_id | name  | reports_count | average_age |
| 9           | Hercy | 2             | 39          |
错误： 
select employee_id
, name
, count(employee_id) over (partition by reports_to) reports_count
, avg(age) over (partition by reports_to) average_age
from Employees
where employee_id in (select reports_to from Employees)
正确：
找到所有经理（reports_to这一列的id），下属员工人数，以及平均年龄，作为子查询】
左连接上一张表，查找经理的姓名】分组
SELECT e.employee_id AS employee_id,
        e.name AS name,
        t.reports_count AS reports_count,
        t.average_age AS average_age
FROM (SELECT reports_to AS manager_id,
             COUNT(employee_id) AS reports_count,
              ROUND(AVG(age),0) AS average_age
      FROM Employees
      WHERE reports_to IS NOT NULL
      GROUP BY reports_to) t
LEFT JOIN Employees e
    ON t.manager_id=e.employee_id
ORDER BY e.employee_id


1789员工的直属部门
一个员工可以属于多个部门。为“Y”的为直属部门。
当员工只加入一个部门的时候，这个部门将默认为他的直属部门，尽管表记录的值为'N'.
请编写解决方案，查出员工所属的直属部门。
Employee table:
| employee_id | department_id | primary_flag |
| 1           | 1             | N            |
| 2           | 1             | Y            |
输出：
| employee_id | department_id |
| 1           | 1             |
| 2           | 1             |
错误：count不能在where里
select employee_id
, department_id
from Employee 
where primary_flag = 'Y' or count(employee_id) = 1 
group by employee_id
order by employee_id
where子句的作用是在分组前，将不符合条件的行去掉，即在分组之前过滤数据，where条件中不能包含聚组函数 
having子句的作用是在分组后过滤数据，即筛选满足条件的组，条件中经常包含聚合函数，
使用having 条件过滤出特定的组，也可以使用多个分组标准进行分组 两者可以连用
正确：
方法一 子查询
员工有两类：
有多个部门的，其中必定有一个部门对应的primary_flag字段值是Y。另一类是只有一个部门。
父查询用来找出第一类员工，子查询用来找出第二类员工。
select employee_id, department_id
from Employee
where primary_flag = 'Y' or employee_id in (
    select employee_id
    from Employee
    group by employee_id
    having count(employee_id) = 1
方法二 UNION
flag=Y的情况】员工只有一个部门的情况】union连接起来去重
select employee_id, department_id
from Employee
group by employee_id
having count(department_id) = 1
union 
select employee_id, department_id
from Employee
where primary_flag = 'Y' ;


610判断是否可形成三角形
Triangle 表:
| x  | y  | z  |
| 13 | 15 | 30 |
select x, y, z, 
    IF(x + y > z and x + z > y and y + z > x, 'Yes', 'No') as triangle from Triangle


    
